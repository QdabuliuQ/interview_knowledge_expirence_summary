* `script`埋点：利用`script`标签会自动发起请求的特点，想后端服务器发起请求，可以动态创建`script`标签，并且将该标签插入到文档当中，只有插入到文档当中才会发起请求
* `img`埋点：利用`img`标签的`src`属性会自动向浏览器发起请求，`img`埋点不需要将`img`标签插入到文档当中，当创建后并且赋值`src`，就会自动发送请求
* `script / img`埋点的区别：`script`方式需要将标签插入到文档当中，`img`不需要；`script`类似于`jsonp`的原理实现，可以处理服务器返回的结果，而`img`不可以。
* `null / undefined`的区别
  `null`表示的一个空对象，`undefined`表示未定义；如果声明了一个变量，但没有赋值，则该值就是`undefined`；`null`一般用于对象的初始化，例如获取`dom`元素：`document.getElementById`，如果获取不到`dom`对象，则返回的是`null`。
* `instanceOf`的原理
  本质是通过获取对象的`__proto__`，判断是否和构造函数的`prototype`相同，如果不相同，不断查找`__proto__`的`__proto__`，直到相同或者为`null`的时候停止
* 异步编程
  回调函数：最早异步编程的解决方案，通过传递回调函数实现，不过容易出现回调地狱问题，代码可维护性和可读性差。
  `promise`：通过`promise`实现异步编程，可以解决回调地狱的问题；执行异步任务函数，然后修改`promise`的状态，通过`then`函数获取到异步任务的执行结果。
  `generator`生成器：通过`function * fn() {}`创建生成器函数，执行函数返回的是`iterator`对象，通过执行`next`方法获取返回结果，相对于`then`链式调用，生成器函数更加直观，同步的写法异步的效果。
  `await / async`：通过标记函数为`async`函数，`await`阻塞后续代码的执行，`await / async`的写法更加直观。
* `async / await`的本质原理：
  `async`本质是`promise`的语法糖，被标记为`async`的函数的返回值是一个`promise`，可以进行链式调用；而`promise`可以解决异步任务回调地狱的问题，`async`本质就是将`promise`的`then`链式调用转为同步代码的写法，使得更加容易维护，可读性更强。
* 七层网络模型
  `osi`的七层网络模型：应用层，表示层，会话层，传输层，网络层，数据链路层，物理层。
  应用层：最靠近用户的一层，提供`http / https / ftp / dns`等服务
  表示层：对应用层的数据进行转为，确保该层应用层的数据能够另一个系统的应用层接收
  会话层：负责建立，终止，管理表示层之间的实体会话
  传输层：负责建立端到端的连接，提供透明可靠的数据传输服务
  网络层：负责建立两个相邻节点的连接，通过`ip`寻址查找合适的路由进行消息的转发
  物理层：数据在物理层通过比特流进行传输
* `tcp`属于哪一层
  `tcp`属于`osi`模型中的传输层。`tcp`全称：传输控制协议，单位是报文段，提供可靠的数据传输服务，在进行通信执行需要进行三次握手建立连接，并且也提供数据包重传，拥塞控制等功能。
* `post / get`的区别
  `get`的请求实体部分为空，`post`请求实体部分是传递的数据
  浏览器通常会对`get`类型的请求进行缓存
  `post`请求发起前，通常会进行一次`option`预检请求
  `get`类型的请求参数是放在`url`当中，相对于`post`请求来说不安全
  `get`类型的请求传递的参数只能是文本类型，`post`参数可以多种
  `get`类型的请求会产生一个`TCP`数据包，`post`类型的请求会产生两个`TCP`数据包，`post`请求，浏览器会先发送`header`，服务器响应`100 continue`，然后再发送`data`，服务器响应`200`
* 什么时候会触发二次预检
  在进行跨域请求的时候，并且是非简单请求，就会进行一次预检请求，判断是否对跨域资源有访问权限。
  简单请求：请求方法：`get / post / head`，请求头：`accept / accept-content / content-type / last-event-id`，超出该范围则是非简单请求，在请求之前会先发起`option`预检请求。
* `react hooks`解决什么问题
  在`hooks`没有出现之前，`react`最小的代码单位都是组件，通常将一些功能划分成一个组件，方便复用；但是当某一些业务代码出现重复的时候，没办法进行抽离，并且在生命周期函数中会掺杂了很多业务不相关的代码，这样会导致组件的维护性降低。
  所以出现了`hooks`，可以将一些业务功能进行抽离，封装作为一个`hook`使用，这样避免过多不相关的代码冗余。
* `vue`的`data`为什么返回函数不返回对象
  如果是一个对象，对象是引用类型的数据，目的是为了防止多个组件实例对象之间公用一个`data`，产生数据污染，修改了一个`data`影响到其他组件的`data`；所以通过执行函数，返回一个全新的`data`对象，可以有效避免这种情况。

