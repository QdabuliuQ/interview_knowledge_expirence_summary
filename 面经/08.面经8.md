* 前后端通信的技术/方法
  `ajax`是一种最常见的前后端通信的技术，可以通过在前端创建`XMLHttpRequest`对象实例，客户端可以主动向服务器发送数据，而服务器无法主动向客户端进行消息发送；可以实现局部刷新，不需要刷新整个页面就可以完成数据的请求。
  `websocket`即时通讯，这种方式最大的特点就是解决了`http`协议只能单方面发送请求的问题，在`websocket`中服务器也可以主动向客户端发送消息。
  `eventSource`：`ajax`轮询比较复杂，`websocket`对服务器资源占用大，`eventSource`是一个轻量级的消息传送`api`，与服务器建立一个持久连接，在`eventSource`中只能是服务器向客户端进行消息推送。

* `websocket`和`eventSource`的区别

  * `eventSource`是基于`http`协议，使用的是`http`的长连接机制，`websocket`是独立的协议，与`http`没有关系
  * `websocket`是支持双向通信，`eventSource`只支持服务器向客户端的单向通信，客户端只能接收数据不能发送数据
  * `websocket`发送的数据格式更加丰富，`eventSource`只能发送文本类型
  * `eventSource`的兼容性相对于`websocket`要更好
  * `websocket`的实时性更强，通行速度和性能都会比`eventSource`高

* `position`属性值

  * `relative`相对，如果设置了`top / left ...`属性，则会相对于原来的位置进行偏移
  * `absolute`绝对，如果设置了`top / left ...`属性，则会相对于其已设置非`static`的父元素进行偏移，并且会脱离文档流
  * `static`静态，`position`属性的默认值
  * `fixed`固定，`fixed`默认情况下是相对于浏览器窗口进行固定定位，它不会随着页面的滚动而移出可视区域；如果父元素设置了`transform`，那么`fixed`定位就会相对于父元素而不是视口
  * `sticky`黏贴，该属性可以是`absolute / fixed`的结合，通过设置阈值，当元素到达这个阈值的时候，就会呈现`fixed`状态

* `http`状态码

  * 200 请求处理成功，客户端发送给服务端的请求能够成功接收并且处理
  * 204 请求处理成功但没有返回内容，客户端的请求在服务端成功处理，当服务端无需向客户端返回内容
  * 206 范围请求，在`http1.1`中引入了范围请求，可以在请求头中的`range`字段获取指定的资源的范围，只读取资源的部分内容；`range: bytes=start-end`，`start`指定起始字节位置，`end`指定结束字节位置，服务器收到后返回状态码`206`
  * 301 永久重定向，表示该资源已经被移动到新的`url`
  * 302 临时重定向，响应头中包含了一个重定向的`url`，客户端应该使用这个`url`来发起后续请求
  * 304`not modified`，该状态和缓存有关，如果资源有效并且没有发生修改，则返回状态码304，浏览器收到会继续使用缓存
  * 400 请求报文存在语法错误，一般是传递的内容或者服务端在处理请求的时候出现错误
  * 401 该请求没有通过服务器的认证
  * 403 服务器收到客户端的请求，但拒绝执行该请求，通常是用户没有权限是访问该资源
  * 404 服务器无法找到请求的资源，或者是该资源不存在
  * 405 服务器不支持该请求方法，客户端进行消息通信的时候使用了服务器不支持的请求方法
  * 500 服务器内部错误，一般是服务器程序运行错误
  * 503 服务器负载或者停机维护

* `vue3`相对于`vue2`有什么优点

  * `vue3`的组合式`api`相对于`option api`更加灵活，可以将逻辑相关的代码封装在一起，增加代码的复用性，避免逻辑代码冗余
  * `vue3`的`template`可以存在多个根标签，这在`vue2`是不允许的
  * `vue3`能更好的`ts`相结合，因为`vue2`主打`option api`，是面向对象的编程，和`ts`不太匹配
  * `diff`算法优化，在`vue2`中会对虚拟`dom`全量对比，不管是否是动态节点；在`vue3`中新增了静态标记，对于静态标记的节点会跳过
  * `hoistStatic`静态提升，对于静态节点只会创建一次，后续直接复用
  * `proxy`替代`defineProperty`实现响应式，`proxy`可以全方位监听数据变化，`defineProperty`无法监听到数组长度变化和对象属性增加

* 父组件怎么调用子组件的方法

  * 可以给子组件添加`ref`属性，并且在子组件中需要给外界调用的方法要放入`defineExpose`当中，在父元素中才可以使用

* 实现动画的方法

  * 通过`css`的`animation`定义动画帧
  * 通过`css`的`transition`定义过渡动画
  * `js`的定时器`setInterval`制定动画
  * `html5`提出的`requestAnimationFrame`请求动画帧

* `js`实现动画和`css`实现动画的优缺点

  * 优点：`js`可以实现更加复杂的动画，可以控制动画的开始暂停，并且相对于`css`来说没有兼容性问题
  * 缺点：由于`js`是单线程的，那么动画又必须是不断刷新执行，可以会影响到其他脚本的执行和动画的流畅度，还有需要写更多的代码去完成动画
  * 优点：`css`实现一些动画非常简单，并且浏览器也有针对性的优化，强制使用`GPU`加速
  * 缺点：稍微复杂点的动画就很难实现，对运行过程无法控制。

* 盒子模型

  盒子模型有两种，一种是标准盒模型，一种是`ie`盒模型；

  * 标准盒模型`box-sizing: content-box`，宽度是由内容`content`决定，`padding / border`不会计算在内
  * `ie`盒模型`bos-sizing: border-box`，宽度由`content + border + padding`决定

* 雪碧图是什么

  雪碧图主要是又多个小图标组合而成的一张大图，将多个小图标一次排列在一张背景颜色是透明的大图当中。
  雪碧图最主要的作用就是可以减少`http`的请求数量，如果不用雪碧图，那么就会存在每一个图表都去请求一次，增加服务器的负载以及浏览器的加载。所以将所有图标都整合到一起，只需要发起一次请求即可。
  缺点就是雪碧图每一个图标的位置都需要精准的排列，以及当雪碧的图表顺序出现更换的时候，前端也需要通过`css`属性进行更换。