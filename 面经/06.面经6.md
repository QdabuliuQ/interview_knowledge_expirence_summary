* `vue-router`两种模式
  有`hash / history`两种模式；前端路由的出现主要是为`SPA`应用能够更好管理页面内容，因为`SPA`只有一个页面，所有内容变化都是在这个页面的基础上来完成，所以需要一个路由管理这些页面和`url`的映射关系；
  `hash`模式最主要的区别就是在`url`中存在`#`号，`#`号后面的属于`hash`值；`hash`虽然出现在`url`当中，但是不会被包括在`http`请求当中，对后端没有影响，并且在进行切换的时候也不会重新加载页面；
  `history`模式是不存在`#`值，利用了`HTML5`中的`history interface`的`pushState / replaceState`，并且当`url`改变的时候，同样不会向服务器发送请求。
  所以`vue-router`利用这两个特性来实现前端路由。
  `hash`模式是通过监听`onhashchange`事件来感知`url`的变化；

* `watch / computed`的区别和使用场景
  `watch`是对某一个值进行监听，这个值必须是`data`定义的或者是`props`传递过来的，可以传递一个回调函数，函数接收到两个值，一个旧值，一个新值，在数据发生变化的时候触发，也可以传递一个配置对象，`immediate / deep`表示是否立即触发，已经是否深度监听变化；`watch`监听的时候不存在缓存，支持异步；
  `computed`是计算属性，只有当计算属性当中依赖的值发生变化的时候，就会进行重新计算；`computed`是支持缓存的，但不支持异步；
  如果一个值是依赖于其他值进行计算的时候，可以使用计算属性，因为计算属性是存在缓存，可以避免一些不必要的计算；如果是需要在数据变动的时候执行异步操作或者开销较大的操作的时候，可以使用`watch`，`watch`允许执行异步操作

* `nextTick`的原理和使用场景
  原理：`nextTick`是`vue`模拟`javascript`的`eventloop`事件循环机制的一种体现；在`vue`中是通过`promise / mutationObserver / setImmediate / setTimeout`来模拟`vue`当中的宏微任务；
  出现`nextTick`的原因主要是因为`vue`在进行视图更新渲染的时候是异步的，如果是同步，那么每次修改数据都需要进行视图的重新渲染，这样对性能消耗极大；并且数据变化的时候也会生成`vdom`，同步的时候就会不断生成`vdom`，同样存在性能问题；所以使用异步更新队列机制；
  `nextTick`是`vue`内部源码当中使用的，同时来暴露出来给开发者进行使用；
  使用场景：如果修改了`dom1`后，`dom2`需要用到`dom1`，这个时候需要将`dom2`获取`dom1`的代码放入`nextTick`回调函数中去执行，才能够获取到渲染过后的`dom1`；如果是在`created`生命周期当中获取`dom`，也需要写在`nextTick`当中，因为`created`阶段`dom`还没有挂载

* `vue`的`data`为什么是一个函数
  由于`vue`当中存在很多组件实例，如果`data`使用的是对象的话，那么会导致多个组件的`data`指向同一个，从而修改一个组件的`data`会影响到其他组件；如果是一个函数，那么在`initData`的时候执行并且返回一个全新的对象，这样就可以保证每一个组件的`data`都是唯一的并且不会相互影响；而`vue`根实例只能有一个，所以可以直接用对象，不需要担心`data`冲突的问题

* 浏览器的渲染过程
  页面渲染可以分为两个阶段，一个是页面内容加载完毕，一个页面资源加载完毕；分别对应了`DOMContentLoaded / load`事件；
  `DOMContentLoaded`事件是值`dom`加载完毕之后触发
  `load`事件是指`dom`，样式表，图片，脚本加载完成后触发
  浏览器渲染的流程主要有`5`步

  1. 将`html`文档解析生成`dom`
  2. 将`css`文档解析生成`cssom(css object model)`
  3. 将`dom`和`cssom`合并成为渲染树`rendering tree`
  4. 通过`rendering tree`将元素进行页面的布局
  5. 将布局好的页面进行绘制

  `css`解析和`dom`解析是可以并行的；

* `defer / async`的区别和使用场景
  `defer`和`async`都是延缓`js`文件的加载，并且可以并行加载`js`文件，不会阻塞`html`文档的解析；
  区别在于`js`文件加载完毕后的执行时机，`defer`是等到`html`文件解析完毕之后再执行`js`文件；而`async`是在`js`文件加载完毕后立即执行，期间可能会暂停`html`文档的解析；
  如果一个`js`文件的优先级较高，则可以使用`async`，普通`js`文件则使用`defer`

* `CDN`的两大核心和原理
  边缘节点：`cdn`网络控制大范围部署边缘节点，这些节点分布在各个地理位置上；边缘节点具备存储和传输的功能，可以缓解源服务器的负载，提供更低更快的访问速度；
  缓存：`cdn`可以使用缓存技术来存储网站的静态内容；当用户请求访问一个资源的时候，会在边缘节点上查找是否有该资源的缓存副本，有则直接返回，没有则向源服务器获取返回给用户，并且缓存在当前的边缘节点；
  原理：首先会选择最近的边缘节点，在用于进行资源请求的时候，会选择离该用户地理位置最近的一台服务器上进行查找，这样提高访问的速度；然后边缘节点中存在该资源的副本，并且没有过期，则直接返回给用户，如果在资源过期了或者是不存在资源，则向源服务器进行查询获取；对于动态内容，`cdn`会请求回源至源访问上处理，如果源服务器生成了动态内容，`cdn`将其缓存到边缘节点中，方便后续的使用；

