* 伪类和伪元素的区别
  伪类：使用`:`冒号进行标识，指的是元素的某一种状态，例如有`hover、active、visited`，都表示了元素的对应的状态，可以设置元素在该状态下的样式，`link -> visited -> hover -> active`执行顺序：`l v h a`
  伪元素：是设置指定元素特定部分的内容和样式，有`after / before`

* 盒模型
  盒模型分为了两种，一种是标准盒模型，也就是`box-sizing: content-box`，标准盒模型的宽度计算方式是：`content内容宽度`；一种是`ie`盒模型，也就是`box-sizing: border-box`，`ie`盒模型的宽度的计算方式是：`content内容宽度 + border边框宽度 + padding内边距`；

* `BFC`
  `BFC`全称块级格式上下文，它是一个独立的渲染区域，不会影响到外部；
  如何创建`BFC`：`float`值设置为除了`none`之外的值，`overflow`值设置为非`visible`值，`position`值设置为非`static / relative`，`display`值设置为`inline-block / table-cell / flex / inline-flex`
  `BFC`的作用：相邻元素的`margin`重叠问题，可以将其中一个元素设置为`BFC`；清除浮动，解决高度塌陷的问题，如果子元素设置`float`浮动，会导致父元素高度塌陷，可以在父元素上添加`overflow: hidden`开启`BFC`

* 选择器优先级
  `id`选择器`(#)`、`class`选择器`(.)`、属性选择器`(ref=["eee"])`、伪类选择器`(:last-child)`、标签选择器`(a)`、伪元素选择器`(:after)`、相邻兄弟选择器`(+)`、子选择器`(ul > li)`、后代选择器`(ul li)`

* `max-width / min-width / width`的优先级关系
  `min-width`的优先级最高，其次就是`max-width`，最后就是`width`

  ```css
  .box {
    /* box宽度为150px */
    height: 100px;
    width: 100px;
    min-width: 150px;
    max-width: 50px;
    background-color: red;
  }
  ```

* 输入`url`到渲染页面的全过程
  1、首先会对输入的`url`进行判断，判断是否是合法的，不合法则交由搜索引擎搜索
  2、对`url`中一些非法字符进行转义，然后进行下一步请求
  3、判断浏览器中是否存在缓存，如果存在，则直接使用，不存在则向`DNS`服务器进行查询
  4、`DNS`服务器会进行迭代查询，去每一个级的`DNS`服务器中查询，如果都没有，最后去权威域名服务器中查询，并且将对应`url`的`ip`地址返回本地`DNS`服务器，本地`DNS`服务器会进行缓存
  5、进行`TCP`三次握手建立连接，首先客户端向服务端发起连接请求，包含了`SYN`报文和初始序列号；然后服务端接收到客户端的连接请求后，会回送`ACK`确认报文，确认报文的值就是序列号值+1，表示服务端收到客户端的连接请求；客户端收到服务端的响应后，会发送`ACK`确认报文，然后进入`establish`状态，服务端收到确认报文后也会进入连接状态
  6、服务端将`html / css`文件传递给客户端
  7、浏览器接收`html / css`文件后，会对`html`解析生成`DOM`，对`css`解析生成`CSSOM`，再将`DOM / CSSOM`合并成为渲染树，在页面中根据渲染树完成布局，然后调用浏览器的`ui`接口进行页面的绘制
  8、`TCP`的四次挥手断开连接；客户端认为服务端数据发送完毕，发起一个连接释放请求，包含了`FIN`包；服务端收到客户端的请求后，释放`TCP`连接，这样客户端就无法向服务端发送数据，而由于`TCP`通信是双向的，服务端任然可以发送数据；当服务器数据发送完毕后，向客户端发起连接释放请求，服务端进入`LAST_ACK`状态；客户端收到服务端的连接释放请求后，会响应一个确认报文`ACK`，然后进入`TIME_WAIT`状态，超过一定时间后`CLOSE`，服务端收到确认报文后`CLOSE`

* 强缓存和协商缓存
  强缓存：是一个缓存技术，通过`expire / cache-control`来判断，强缓存不会进入任何的网络请求，当强缓存命中的时候，则会使用本地的缓存进行加载，否则考虑使用协商缓存；
  `expire`属性表示资源的过期时间，由于是个绝对时间，在该时间内资源都是有效，但存在一个问题，就是用户可以修改本地时间，导致影响缓存命中；
  `cache-control`可以设置`max-age`值进行判断，设置资源的最大有效期；
  `cache-control`的优先级要大于`expire`
  协商缓存：当强缓存未命中的时候，使用协商缓存，协商缓存一定会进行一次网络请求，从而判断是否使用本地资源还是新资源，通过`Etag / Last-modified`进行判断
  `Last-modified`：表示资源的上一次修改时间，在第一次请求资源的时候，服务端会返回`Last-modified`，后续请求的时候，请求头会带上`if-modify-since`，值为`last-modified`对应的值，服务端接收后会和当前文件判断，判断是否发生的修改，没有修改返回`304`，修改返回新文件和`200`
  `Etag`：会根据文件内容生成的唯一标识，根据内容的来进行生成，当内容发生变动的时候，`Etag`也会发生变动，在第一次请求的时候，服务端会返回`Etag`值给浏览器，后续对该资源进行请求的时候，会在请求头中添加`if-none-match`，值为`Etag`的值，服务端对传递的`if-none-match`和当前文件的`Etag`进行判断

* `CDN`是什么
  `CDN`全称：内容分发网络，是一种通过互联网相互连接的电脑网络系统，利用最靠近用户的服务器，向用户发送数据，这些数据可以是图片，音频等。`CDN`服务器由三部分组成：分发服务系统，均衡负载系统，运营管理系统；
  `CDN`的作用：可以将一些静态资源存放到`CND`当中，由于`CDN`在请求数据的时候，在到最靠近用户的数据中心中获取数据并且返回，所以加载资源的速度更快；可以用于托管`web`资源，项目部署；以及可以将部分请求分配给`CDN`，减轻服务器的负载；`CDN`也可以预防`DDOS`攻击，它可以监听流量，对于异常流量会限制其请求的频率

* `TLS/SSL`
  `TLS/SSL`全称：安全传输层协议；介于`TCP`和`http`之间的一层安全协议；主要是对数据进行加密和解密的作用。
  `TLS/SSL`实现主要有三类算法：对称加密，非对称加密，散列函数；
  散列函数：常见的散列函数：`MOD5，SHA1`，散列函数对输入数据敏感，不可逆；
  对称加密：通信双方使用同一个密钥进行数据的加密，这种方式简单高效，但存在一个问题，就是如何将密钥进行传递，密钥在传递过程中存在被中间人截取的风险
  非对称加密：存在两个密钥，一个公钥一个私钥，私钥是保密的，公钥是公开的，用公钥加密的数据需要使用对应的私钥才能进行解密；通信双方在开始通信前都会相互发送自己的公钥，之后发送的数据都使用对方的公钥进行加密，接收数据使用自己的私钥解密数据。非对称加密存在的问题就是加密过程长。
  `TLS/SSL`在客户端使用非对称加密和服务端进行通信，实现身份验证并协商对称加密使用的密钥

* `router`和`route`的区别
  `router`是路由实例，包含了路由的跳转方法和钩子函数；`route`是路由信息对象，包含了当前路由的信息，`path / query/ fullpath / hash / name ...`
  
* 手写`Promise.all`方法
  
  ```javascript
  Promise.all = function(promises) {
    let res = []
    let cnt = 0
    const processData = (i, data, resolveFn) => {
      res[i] = data  // 将结果放入与之对应的数组位置中
      cnt ++  // 成功次数增加
      if(cnt === promises.length) {  
        resolve(res)  // 修改promise状态 并且传入成功数组
      }
    }
    // 返回全新的promise
    return new Promise((resolve, reject) => {
      for(let i = 0; i < promises.length; i ++) {  // 遍历promise
        promises[i].then((res) => {  // 给所有promise添加成功失败回调
          processData(i, res, resolve)  // 成功调用函数 传入索引位置和res返回值 以及resolve函数
        }, reject)
      }
    })
  }
  ```
  
  